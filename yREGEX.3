.TH yREGEX 3 2017-nov "linux" "heatherly custom tools manual"
.na

.SH NAME
yREGEX \- powerful, focused, small-volume regular expression library

.SH SUMMARY
yREGEX is a transparent library for small-volume, day-to-day regular expression
matching based on ken thompsons finite automata algorithm (not recursion)
plus added back references and sub-match rules.

.SH CAVEAT (deeper learning, bootstrapping, and dogfooding)
i wanted to understand, learn, and never migrate, so i built it.  yREGEX is
optimized for transparency, debugging, and tracing, AND it also runs at
reasonable (not blazing, but decent) production speed.  when speed becomes
an issue, i'll dig in and tune harder.  if you want cutting-edge coverage,
data warehousing speeds, and runtime optimization, buy a commercial library ;)

.SH SYNOPSIS
.nf
---(header)------------------------------------
.B #include  <yREGEX.h>
.sp
---(regex)-------------------------------------
.BI "char  yREGEX_comp   (cchar *" "a_regex" ");"
.BI "char  yREGEX_exec   (cchar *" "a_text " ");"
.BI "char  yREGEX_fast   (cchar *" "a_text " ");"
.sp
---(best solution)-----------------------------
.BI "char  yREGEX_best   (cchar  " "a_type " ", cchar " "a_side" ","
.BI " " "                    " "int   *" "a_beg  " ", int  *" "a_len"  ","
.BI " " "                    " "int   *" "a_fbeg " ", int  *" "a_flen" ");"
.sp
---(match cursoring)---------------------------
.BI "char  yREGEX_method (cchar  " "a_type " ");"
.BI "char  yREGEX_cursor (cchar  " "a_dir  " ","
.BI " " "                    " "int   *" "a_beg  " ", int  *" "a_len"  ","
.BI " " "                    " "int   *" "a_fbeg " ", int  *" "a_flen" ");"
.sp
---(linking)-----------------------------------
.B link with -L/usr/local/libs -lyREGEX or -lyREGEX_debug

.SH LANGUAGE DEFINITION
yREGEX uses the 14 posix standard regular expression meta-characters, plus a
few additional ones (and my extended ascii) for ease and more functionality.
this will NOT explain regular expressions in detail.

.B characters ------------------------------------------- posix
   .               any character
   \\.              explicitly a period
   \\w \\s \\d \\p     :word:, :space:, :digit:, :punct:
   \\a \\l \\u \\g \\x  :alpha:, :lower:, :upper:, :greek:, :xdigi:
   \\f \\t \\e \\n \\c  field, tab, escape, return, control
   \\W \\D \\S \\F \\G  reverse of those above

.B quanfifiers ------------------------------------------ posix
   ?      !        zero or one, greedy and lazy        (not ??)
   +      ~        one or more, greedy and lazy        (not +?)
   *      @        zero or more, greedy and lazy       (not *?)
   {m}             exactly m times
   {m,n}  {-m,n}   m to n times, greedy and lazy
   {n}             up to n times

.B logic and grouping ----------------------------------- posix too
   |               alternation (either-or)
   (...)           default, non-capturing group        (...)
   ∏...π           capturing group (1 - 9) explicit    (#...)
   º...Ω           focus group for final positioning   (>...<)

.B classes ---------------------------------------------- posix
   [...]           any one of the characters included
   [^...]          not any of the characters included
   m-n             any character between m and n (inclusive) 

.B anchors ---------------------------------------------- posix
   ^     $         begin and end of string
   <     >         begin and end of word               (not µb µB)

.B saved patterns --------------------------------------- posix
   &.    (&.....)    saved patterns for reuse by abbr or short name
   &f    (&float)    ... float number
   &i    (&int)      ... signed integer
   &b    (&byte)     ... and a byte in integer form
   &w    (&word)     ... word plus word boundaries
   (&1)              pattern saved from 1st capture group

.B sub-match rules -------------------------------------- posix too
   ∫nÂmª      two capture groups must match            (;n==m)
   ∫nﬂmª      two groups must be different             (;n!=m)
   ∫n<mª      first group must sort earlier            (;n<m)
   ∫n>mª      first group must sort later              (;n>m)
   ∫n›mª      first group must sort same or earlier    (;n<=m)
   ∫nﬁmª      first group must sort same or later      (;n>=m)
   ∫n+...ª    contains the substring                   (;n+...)
   ∫n-...ª    does not contain substring               (;n-...)
   ∫n\\uª      has a char in standard set               (;n\\u)
   ∫n[...]ª   has a char in custom set                 (;n[...])
   ∫n[^...]ª  does not have any char in set            (;n[^...])
   ∫n...ª     freeform regex sequence for matching     (;n...)

.B regex prefix ----------------------------------------- maybe
   this feature will be used only inside programs to short-cut
   later requests for a solution <type> and <start>. all of these
   prefixes are meta-characters and would be illegal if used first.
   $          best solution based on regex operator (*?+@!~)
   *          greediest overall
   ?          leftmost greedy
   +          rightmost greedy
   @          laziest overall
   !          leftmost lazy
   ~          rightmost lazy
   #          numeric search (see below)

.B numeric match prefix---------------------------------- maybe
   while not a regex, numeric ranges are key searching mechanisms, so
   yREGEX will interpret these symbols as well
   #=n        equal                                    #==n
   #ﬂn        not equal                                #!=n
   #<n        less than                                #<n
   #>n        greater than                             #>n
   #›n        less than or equal                       #<=n
   #ﬁn        greater than of equal                    #>=n
   #n±m       inclusive range by absolutes             #n><m
   #n%m       inclusive range by percents              #n%m
   #!n±m      exclusion of range by absolutes          #!n><m
   #!n%m      exclusion of range by percents           #!n%m
   #¥¥¥|¥¥¥   or conjunction                           #¥¥¥|¥¥¥

.B spacers (for readability) ---------------------------- new
   ≤ ¥ ≥ ¨        used in any combination or number
   ≤≤≤∫...ª       sometimes this before the rule section can help
   ∫...ª¥∫...ª    the medium dot is nice between rules for clarity

.SH REGEX FUNCTIONS
yREGEX is pretty standard stuff from an interface standpoint, but
a little simplier, just because it is not re-entrant yet so it does
not require pointers to maintain context.

.B yREGEX_comp (<regex>)
takes one argument, a plain-text c-string containing the regular expression.
it then verify and precompile its contents for execution.  a negative return
value means the regex was not correct.

.B yREGEX_exec (<text>)
takes one argument, a plain-text c-string containing the text to be searched.
the compiled regex is used to find matches and the number of matches found
is returned.

.B yREGEX_fast (<text>)
same as yREGEX_exec, but returns once a single match is found.  this is useful
when just filtering matching lines.

.SH BEST SOLUTION and MATCH CURSOR FUNCTIONS
yREGEX is a little different here as it does not return match arrays for the
source program to iterate over.  yREGEX_exec returns the number of matches
(100 means >= 100).  yREGEX then provides two levels of solution access.

.B yREGEX_best (<type>, <start>, <beg>, <len>, <fbeg>, <flen>)
.RS 3
returns the best match based on the first two arguments.
.RE

.RS 3
.B <type>
   YREGEX_GREEDY   biggest match,
   YREGEX_LAZY     smallest match, or
   YREGEX_BEST     scored using regex (always YREGEX_MOST).

.B <start>
   YREGEX_LEFT     leftomst match,
   YREGEX_RIGHT    rightmost match, or
   YREGEX_MOST     most greedy or lazy match based on <type>.

.B <beg>
returns the start position of selected match (may be NULL).

.B <len>
returns the length of selected match (may be NULL).

.B <fbeg>
returns the start position of ºfocusΩ group (may be NULL).

.B <flen>
returns the length of ºfocusΩ group (may be NULL).
.RE

.B yREGEX_method (<type>)
.RS 3
prepares the match cursor for one of two types of matches as shown above
(yREGEX_greedy, yREGEX_lazy).  defaults to greedy.
.RE

.B yREGEX_cursor (<dir>, <beg>, <len>, <fbeg>, <flen>)
.RS 3
walks through the matches for the type set in yREGEX_method.  same as
yREGEX_best, it returns both the match beg and length as well as the focus
group beg and length.
.RE

.RS 3
.B <dir>
is '['=head '>'=next '.'=curr '<'=prev ']'=last

.B <beg>, <len>, <fbeg>, and <flen>
same as yREGEX_best.
.RE

.SH FLAWS
.B not re-entrant,
can not be used on two regex patterns simultaneously.

.B not recursive,
so different solution orders that standard libraries.

.B named patterns
are internally compiled, and so not as flexible

.SH SEE ALSO
this documentation is layered to provide easier navigation.
   yREGEX  (3), library overview and calling
   yREGEX  (7), decision rationale, objectives, and overview

.SH AUTHOR
heatherly <jelloshrke at gmail dot com>

.SH COLOPHON
this page is part of a documentation package mean to make the use of the
heatherly tools easier and faster

