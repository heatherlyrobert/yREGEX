.TH yREGEX 3 2017-nov "linux" "heatherly custom tools manual"
.na

.SH NAME
yREGEX \- transparent and flexible regular expression library

.SH SUMMARY
yREGEX is a clean and useful library for day-to-day regular expression matching
based on ken thompsons wicked fast finite automata algorithm (not recursion)
plus added back references and sub-match rules.

.SH CAVEAT (deeper learning, bootstrapping, and dogfooding)
i wanted to understand, learn, and never migrate, so i built it.  yREGEX is
optimized for transparency, debugging, and tracing, AND it also runs at
reasonable (not blazing, but decent) production speed.  when speed becomes
an issue, i'll dig in and tune harder.  if you want cutting-edge coverage,
data warehousing speeds, and runtime optimization, buy a commercial library ;)

.SH SYNOPSIS
.nf
---(header)------------------------------------
.B #include  <yREGEX.h>
.sp
---(regex)-------------------------------------
.BI "char  yREGEX_comp   (cchar *" "a_regex" ");"
.BI "char  yREGEX_exec   (cchar *" "a_text " ");"
.BI "char  yREGEX_fast   (cchar *" "a_text " ");"
.sp
---(matches)-----------------------------------
.BI "char  yREGEX_best   (cchar  " "a_type " ", cchar " "a_side" ", int *" "a_beg" ", int *" "a_len" ");"
.BI "char  yREGEX_method (cchar  " "a_type " ");"
.BI "char  yREGEX_cursor (cchar  " "a_dir  " ", int *" "a_beg" ", int *" "a_len" ");"
.sp
---(linking)-----------------------------------
.B link with -L/usr/local/libs -lyREGEX or -lyREGEX_debug

.SH LANGUAGE DEFINITION
yREGEX uses the 14 posix standard regular expression meta-characters, plus a
few additional ones (and my extended ascii) for ease and more functionality.
this will NOT explain regular expressions in detail.

.B characters ------------------------------------------- posix
   .               any character
   \\.              explicitly a period
   \\w \\s \\d \\p     :word:, :space:, :digit:, :punct:
   \\a \\l \\u \\g \\x  :alpha:, :lower:, :upper:, :greek:, :xdigi:
   \\f \\t \\e \\n \\c  field, tab, escape, return, control
   \\W \\D \\S \\F \\G  reverse of those above

.B quanfifiers ------------------------------------------ posix
   ?      !        zero or one, greedy and lazy        (not ??)
   +      ~        one or more, greedy and lazy        (not +?)
   *      @        zero or more, greedy and lazy       (not *?)
   {m}             exactly m times
   {m,n}  {-m,n}   m to n times, greedy and lazy
   {n}             up to n times

.B logic and grouping ----------------------------------- posix too
   |               alternation (either-or)
   (...)           default, non-capturing group        (...)
   ∏...π           capturing group (1 - 9) explicit    (#...)
   º...Ω           focus group for final positioning   (>...<)

.B classes ---------------------------------------------- posix
   [...]           any one of the characters included
   [^...]          not any of the characters included
   m-n             any character between m and n (inclusive) 

.B anchors ---------------------------------------------- posix
   ^     $         begin and end of string
   <     >         begin and end of word               (not µb µB)

.B saved patterns --------------------------------------- posix
   &.    (&.....)    saved patterns for reuse by abbr or short name
   &f    (&float)    ... float number
   &i    (&int)      ... signed integer
   &b    (&byte)     ... and a byte in integer form
   &w    (&word)     ... word plus word boundaries
   (&1)              pattern saved from 1st capture group

.B sub-match rules -------------------------------------- posix too
   ∫nÂmª      two capture groups must match            (;n==m)
   ∫nﬂmª      two groups must be different             (;n!=m)
   ∫n<mª      first group must sort earlier            (;n<m)
   ∫n>mª      first group must sort later              (;n>m)
   ∫n›mª      first group must sort same or earlier    (;n<=m)
   ∫nﬁmª      first group must sort same or later      (;n>=m)
   ∫n+...ª    contains the substring                   (;n+...)
   ∫n-...ª    does not contain substring               (;n-...)
   ∫nµuª      has a char in standard set               (;nµu)
   ∫n[...]ª   has a char in custom set                 (;n[...])
   ∫n[^...]ª  does not have any char in set            (;n[^...])
   ∫n...ª     freeform regex sequence for matching     (;n...)

.B regex prefix ----------------------------------------- maybe
   this feature will be used only inside programs to short-cut
   later requests for a solution <type> and <start>. all of these
   prefixes are meta-characters and would be illegal if used first.
   $          best solution based on regex operator (*?+@!~)
   *          greediest overall
   ?          leftmost greedy
   +          rightmost greedy
   @          laziest overall
   !          leftmost lazy
   ~          rightmost lazy

.B spacers (for readability) ---------------------------- new
   ≤ ¥ ≥ ± ¨      used in any combination or number
   ≤≤≤∫...ª       sometimes this before the rule section can help
   ∫...ª¥∫...ª    the medium dot is nice between rules for clarity

.SH REGEX FUNCTIONS
yREGEX is pretty standard stuff from an interface standpoint, but
a little simplier, just because it is not re-entrant yet so it does
not require pointers to maintain context.

.B yREGEX_comp (<regex>)
takes one argument, a plain-text c-string containing the regular expression.
it then verify and precompile its contents for execution.  a negative return
value means the regex was not correct.

.B yREGEX_exec (<text>)
takes one argument, a plain-text c-string containing the text to be searched.
the compiled regex is used to find matches and the number of matches found
is returned.

.B yREGEX_fast (<text>)
same as yREGEX_exec, but returns once a single match is found.  this is useful
when just filtering or counting matching lines.

.SH SOLUTION FUNCTIONS
yREGEX is a little different here as it does not return match arrays for the
source program to iterate over.  yREGEX_exec returns the number of matches
(100 means >= 100).  yREGEX then provides two levels of solution access.

.B yREGEX_best (<type>, <start>, <beg>, <len>)
this returns what is determined to be the best match based on the first two
arguments.

.RS 3
.B <type>
   YREGEX_GREEDY   biggest match,
   YREGEX_LAZY     smallest match, or
   YREGEX_BEST     scored using regex (always YREGEX_MOST).

.B <start>
   YREGEX_LEFT     leftomst match,
   YREGEX_RIGHT    rightmost match, or
   YREGEX_MOST     most greedy or lazy match based on <type>.

.B <beg>
returns the start position of the selected match.

.B <len>
returns the length of the selected match.
.RE

.B yREGEX_method (<type>)
prepares the match cursor for one of the three types of matches as shown
above (yREGEX_best).

.B yREGEX_cursor (<dir>, <beg>, <len>)
walks through the finds for the type set with yREGEX_method.  a move past
the beginning or end will return negative <beg> and <len> but not adjust
the position.

.RS 3
.B <dir>
[ head > next . curr < prev ] last.

.B <beg> and <len>
same as yREGEX_best.
.RE

.SH FLAWS
.B not re-entrant,
can not be used on two regex patterns simultaneously.

.B not recursive,
so different solution orders that standard libraries.

.B named patterns
are internally compiled, and so not as flexible

.SH SEE ALSO
this documentation is layered to provide easier navigation.
   yREGEX  (3), library overview and calling
   yREGEX  (7), decision rationale, objectives, and overview

.SH AUTHOR
heatherly <jelloshrke at gmail dot com>

.SH COLOPHON
this page is part of a documentation package mean to make the use of the
heatherly tools easier and faster

