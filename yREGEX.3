.TH yREGEX 3 2017-nov "linux" "heatherly custom tools manual"

.SH NAME
yREGEX \- small, fast, clean, and custom regular expression library

.SH SYNOPSIS
.nf
.B #include  <yREGEX.h>
.sp
---(regex)-------------------------------------
.BI "char  yREGEX_comp  (cchar *" "a_regex" ");"
.BI "char  yREGEX_exec  (cchar *" "a_text " ");"
.BI "char  yREGEX_find  (cchar  " "a_type " ", cchar " "a_side" ", int *" "a_beg" ", int *" "a_len" ");"
.sp
---(conversion)--------------------------------
.sp
---(logging/unit testing)----------------------
.BI "char* yREGEX_version    (void);"
.BI "char  yREGEX__unitquiet (void);"
.BI "char  yREGEX__unitloud  (void);"
.BI "char  COMP__unit        (char *" "a_question" ", int " "a_num" ");"
.BI "char  FIND__unit        (char *" "a_question" ", int " "a_num" ");"
.BI "char  PATS__unit        (char *" "a_question" ", int " "a_num" ");"
.BI "char  SETS__unit        (char *" "a_question" ", int " "a_num" ");"
.BI "char  yREGEX__unitend   (void);"
.sp
.B link with -L/usr/local/libs -lyREGEX or -lyREGEX_debug

.SH FLAWS
.B not re-entrant (yet).  

.B no back references (yet).  
mainly for xml, html, etc tags

.B no filtering, like pos/neg look-aheads (yet).  

.B finds different primary solutions that standard libraries.
since it is not recursive (great), that means it does not give priority to
first branches, etc like a recursive algorighm does.

.SH POSSIBLE FEATURES
.B pipelining
maybe use the semi-colon to provide a secondard regex for evaluating the result
of the previous regex.  this would allow me to implement rules for content, like
a password must contain a number, lower, upper, and punctuation.

.B solution prefixing
many modern regex examples are based on a recursive algorithm to find the
first branch of an "or" first.  but, mine does not.  so, i could use a prefix
to indicate the solution evaluation, like greediest, laziest, etc.

   @          overall laziest
   !          leftmost, laziest
   ?          leftmost, greediest
   *          overall greediest

.SH LANGUAGE ADDITIONS
yREGEX uses the 14 standard extended regular expression meta-characters,
plus a few additional ones for either ease or more functionality.  i will
not explain regular expressions or the standard characters, that is well
documented elsewhere.

.B new quantifier variations
   @           lazy version of 0-many, hated *? notation
   ~           lazy version of 1-many, hated +? notation
   !           lazy version of 0-1   , hated ?? notation
   {-...}      lazy version of {...} , common notation
   {m}         exact match, instead of {m,m}

.B new grouping variations
   (...)       non-capturing group (hidden)
   (#...)      capturing group
   (>...<)     focus group, produces default results (ascii art)
   &           "and", to give multiple rules for a single area

.B saved patterns for tried and true receipes
   $.    ($.....)    saved patterns for reuse by abbr or short name
   $f    ($float)    regex pattern for a float number
   $i    ($int)      ... signed integer
   $b    ($byte)     ... and a byte in integer form
   ($1)              pattern saved from a capture group

.B new anchor variations
   <           beginning of word, hated \\b
   >           end of word      , hated \\B

.B new escape variations
   \\f  \\F      field and group separators in my files (or not)
   \\g  \\G      greek letter, same as [:greek:] below (or not)

.B new posix-type class variations
   [:greek:]   my greek letters at the top of ascii 8bit

.SH RATIONAL LIMITS
yREGEX is a 80% solution.  it is meant to fulfill my day-to-day needs while
being maintainable, flexible, and tailored.  if i need serious regex crunching,
i will use a professional, optimizing library ;)

.SH SEE ALSO
this documentation is layered to provide easier navigation.
   yREGEX  (3), library overview and calling
   yREGEX  (7), decision rationale, objectives, and overview

.SH AUTHOR
heatherly <jelloshrke at gmail dot com>

.SH COLOPHON
this page is part of a documentation package mean to make the use of the
heatherly tools easier and faster

