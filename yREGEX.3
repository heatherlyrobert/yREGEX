.TH yREGEX 3 2017-nov "linux" "heatherly custom tools manual"
.na

.SH NAME
yREGEX \- transparent and flexible regular expression library

.SH SUMMARY
yREGEX is a tight and useful library for day-to-day regular expression matching
based on ken thompsons wicked fast finite automata algorithm (not recursion)
plus i added back references and sub-match rules.

.SH CAVEAT (deeper learning, bootstrapping, and dogfooding)
i wanted to understand, learn, and never need to migrate, so i built it.
if you want cutting-edge coverage, data warehousing speeds, and runtime
optimization, buy a commercial library ;)

.SH SYNOPSIS
.nf
.B #include  <yREGEX.h>
.sp
---(regex)-------------------------------------
.BI "char  yREGEX_comp  (cchar *" "a_regex" ");"
.BI "char  yREGEX_exec  (cchar *" "a_text " ");"
.BI "char  yREGEX_find  (cchar  " "a_type " ", cchar " "a_side" ", int *" "a_beg" ", int *" "a_len" ");"
.sp
.B link with -L/usr/local/libs -lyREGEX or -lyREGEX_debug

.SH LANGUAGE DEFINITION
yREGEX uses the 14 posix standard regular expression meta-characters, plus a
few additional ones (and my extended ascii) for ease and more functionality.
this will NOT explain regular expressions in detail.

.B characters ------------------------------------------- posix
   .               any character
   \\.              explicitly a period
   \\w \\s \\d \\p     :word:, :space:, :digit:, :punct:
   \\a \\l \\u \\g \\x  :alpha:, :lower:, :upper:, :greek:, :xdigi:
   \\f \\t \\e \\n \\c  field, tab, escape, return, control
   \\W \\D \\S \\F \\G  reverse of those above

.B quanfifiers ------------------------------------------ posix
   ?      !        one or none, greedy and lazy        (not ??)
   +      ~        one or more, greedy and lazy        (not +?)
   *      @        zero or more, greedy and lazy       (not *?)
   {m}             exactly m times
   {m,n}  {-m,n}   m to n times, greedy and lazy
   {n}             up to n times

.B logic and grouping ----------------------------------- posix too
   |               alternation (either-or)
   (...)           default, non-capturing group        (...)
   ∏...π           capturing group (1 - 9) explicit    (#...)
   º...Ω           focus group for final positioning   (>...<)

.B classes ---------------------------------------------- posix
   [...]           any one of the characters included
   [^...]          not any of the characters included
   m-n             any character between m and n (inclusive) 

.B anchors ---------------------------------------------- posix
   ^     $         begin and end of string
   <     >         begin and end of word               (not µb µB)

.B saved patterns --------------------------------------- posix
   &.    (&.....)    saved patterns for reuse by abbr or short name
   &f    (&float)    ... float number
   &i    (&int)      ... signed integer
   &b    (&byte)     ... and a byte in integer form
   &w    (&word)     ... word plus word boundaries
   (&1)              pattern saved from 1st capture group

.B sub-match rules -------------------------------------- posix too
   ∫nÂmª      two capture groups must match            (;n==m)
   ∫nﬂmª      two groups must be different             (;n!=m)
   ∫n<mª      first group must sort earlier            (;n<m)
   ∫n>mª      first group must sort later              (;n>m)
   ∫n›mª      first group must sort same or earlier    (;n<=m)
   ∫nﬁmª      first group must sort same or later      (;n>=m)
   ∫n+...ª    contains the substring                   (;n+...)
   ∫n-...ª    does not contain substring               (;n-...)
   ∫nµuª      has a char in standard set               (;nµu)
   ∫n[...]ª   has a char in custom set                 (;n[...])
   ∫n[^...]ª  does not have any char in set            (;n[^...])
   ∫n...ª     freeform regex sequence for matching     (;n...)

.B spacers (for readability) ---------------------------- new
   ≤ ¥ ≥ ± ¨      used in any combination or number
   ≤≤≤∫...ª       sometimes this before the rule section can help
   ∫...ª¥∫...ª    the medium dot is nice between rules for clarity

.SH FLAWS
.B not re-entrant,
can not be used on two regex patterns simultaneously.

.B not recursive,
so different solution orders that standard libraries.

.B named patterns
are internally compiled, and so not as flexible

.SH POSSIBLE FEATURES
.B solution prefixing
many modern regex examples are based on a recursive algorithm to find the
first branch of an "or" first.  but, mine does not.  so, i could use a prefix
to indicate the solution evaluation, like greediest, laziest, etc.

   @          overall laziest
   !          leftmost, laziest
   ?          leftmost, greediest
   *          overall greediest

.SH SEE ALSO
this documentation is layered to provide easier navigation.
   yREGEX  (3), library overview and calling
   yREGEX  (7), decision rationale, objectives, and overview

.SH AUTHOR
heatherly <jelloshrke at gmail dot com>

.SH COLOPHON
this page is part of a documentation package mean to make the use of the
heatherly tools easier and faster

