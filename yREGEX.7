.TH yREGEX 7 2017-nov "linux" "heatherly custom tools manual"

.SH NAME
yREGEX \- decision rationale, objectives, and overview

.SH SUMMARY
yREGEX is a fast, clean, tunable, and debuggable library for regular expression
processing to provide tailored and completely uniform regex support across
my platform -- and, one regex to rule them all ;)

.SH BACKSTORY
.B concept.  
regular expressions are a critical computer science theory to efficently
describe, match, validate, extract, and manipulate human-language textual
patterns within larger blocks of text.

.B theory origin.  
in 1956, mathematician stephen cole kleene formalized the concept of a
regular language which could be described using his regular set notation.  all
theory at this point.

.B initial computer use.  
ken thompson was the first to migrate this concept into computer programs,
including the unix editor ed, using wicked fast, non-determinant finite
automota algorithms.

.B spread.
regex spread to vi, grep, awk, sed, emacs, databases, etc and into the posix
standard in 1992.  since the 1980's, tcl and perl have been advancing regex's
far beyond their original bounds.

.SH SCOPE, REASONING and DECISION
.B situation (S).  
there are a large number of freely available standard regular expression
libraries.  they typically implement the posix regular expression standard
plus many, many, many extensions.

.B complication (C).  
current libraries are very big, complex, opaque, optimizing affiars requiring
ineffecient algorithms to support crazy features.  i do not wish to shackle
myself to one of these monsters.

.B solution (S).  
i will develop a variation based on efficient thompson algorithms to implement
the entire posix-extended language, plus a few hand-picked extras which will
support all my tools.

.B target user (T).  
me, just me.  i am a dogfooder and bootstrapper.

.B regular expression concerns
   -- huge volumes of duplicate, replicated, and copied text patterns
   -- parentheses for everything which eats up the capture groups
   -- backslashes are much, much too common (brutal to read)
   -- kitchen sink additions to what should have been a focused thing
   -- reportedly slow algorithms due to increased feature load
   -- recursive algorithms with postentially exponential run-times
   -- use of crazy pos/neg look-aheads to target a find string
   -- way too complex code so everyone relies on faceless maintainers
   -- summary, the mini-language, engines, and algorithms got fugly

.B what i intend to do
   -- use thompsons non-determinant finite automata algorithm
   -- add a huge amount of my standard debugging and tracing logic
   -- compile each regex first to create a wicked easy execution path
   -- support full posix extended regular expression standard (ERE)
   -- implement the 14 base metacharacters   .[]  *+?  {}  ^$  ()|  \\
   -- add short, lazy versions of *+? using the @~! symbols
   -- make set comparisons wicked fast since it is so common
   -- (...) become non-capuring groups rather than (?:...)
   -- (#...) become capuring groups to make them stand out
   -- (>...<) for the primary focus to avoid looks (?>=...), etc
   -- add support for pre-defined patterns, like int, byte, url, etc.
   -- (&n) support saving patterns from capture groups for reuse
   -- adjustable solution finding, i.e., first, last, longest, ...

.B what i refuse to do
   -- no optimization (that code is amazing, but crazy stuff)
   -- no unicode, international, or other encodings
   -- make a kitchen-sink solution with all the perl cruft

.B as always, all my applications must (#).  
   -- run on any linux box from raspberry to cray
   -- stay focused, small, tight, reliable, and secure
   -- focus on maintainability and debugging, not just speed
   -- forgo sloppy, kitchen-sink languages, like python, java, or perl
   -- stay away from dependency on external code libraries, like boost
   -- only human-readable, 8-bit safe, ascii streams (not database)
   -- have dedicated, maintained, automated unit testing
   -- provide either detailed reporting or logging for debugging
   -- use secure communications between systems where required
   -- clean, clean code so i can maintain after long absences
   -- no international, multi-lang, multi-byte support (freaking ever)
   -- all tables must be self describing with labels and queries
   -- all data structures must include dumps, reports, and audits

.SH SEE ALSO
this documentation is layered to provide easier navigation.
   yREGEX  (3), library overview and calling
   yREGEX  (7), decision rationale, objectives, and overview

.SH AUTHOR
heatherly <jelloshrke at gmail dot com>

.SH COLOPHON
this page is part of a documentation package mean to make the use of the
heatherly tools easier and faster

